<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂêàÊàêÂ§ßË•øÁìú</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        /* ÁôªÂΩïÂå∫ÂüüÊ†∑Âºè */
        .auth-section {
            background: rgba(255, 255, 255, 0.15);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .auth-section h2 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 2rem;
            background: linear-gradient(45deg, #ff9a9e, #fad0c4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #fff;
            font-weight: 500;
        }

        input {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transition: all 0.3s ease;
        }

        input:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(45deg, #FF416C, #FF4B2B);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 75, 43, 0.4);
        }

        .secondary-btn {
            background: transparent;
            border: 2px solid #667eea;
        }

        .switch-text {
            text-align: center;
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.8);
        }

        .switch-link {
            color: #667eea;
            cursor: pointer;
            text-decoration: underline;
        }

        .message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
        }

        .success {
            background: rgba(0, 255, 0, 0.2);
            color: #51cf66;
            border: 1px solid #51cf66;
        }

        /* Ê∏∏ÊàèÂå∫ÂüüÊ†∑Âºè */
        .game-section {
            display: none;
            width: 100%;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .score-container {
            display: flex;
            gap: 20px;
        }

        .score-box {
            text-align: center;
        }

        .score-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .score-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .game-area {
            position: relative;
            width: 500px;
            height: 600px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin: 0 auto 20px auto;
            cursor: pointer;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }

        .control-btn {
            background: linear-gradient(45deg, #11998e, #38ef7d);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(56, 239, 125, 0.6);
        }

        .leaderboard-btn {
            background: linear-gradient(45deg, #FF416C, #FF4B2B);
            box-shadow: 0 5px 15px rgba(255, 75, 43, 0.4);
        }

        .leaderboard-btn:hover {
            box-shadow: 0 8px 20px rgba(255, 75, 43, 0.6);
        }

        .logout-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            width: auto;
            padding: 8px 16px;
            font-size: 14px;
        }

        /* ÊéíË°åÊ¶úÂºπÁ™óÊ†∑Âºè */
        .leaderboard-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .leaderboard-content {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .leaderboard-content h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #ffd700;
            font-size: 1.8rem;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .leaderboard-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .leaderboard-item:nth-child(1) {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            font-weight: bold;
        }

        .leaderboard-item:nth-child(2) {
            background: linear-gradient(45deg, #c0c0c0, #e0e0e0);
            color: #333;
            font-weight: bold;
        }

        .leaderboard-item:nth-child(3) {
            background: linear-gradient(45deg, #cd7f32, #e59b4a);
            color: #333;
            font-weight: bold;
        }

        /* Ê∏∏ÊàèÁªìÊùüÂºπÁ™ó */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            display: none;
        }

        .game-over h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #FF416C;
        }

        .game-over p {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        .hidden {
            display: none;
        }

        .next-fruit {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }

        .next-fruit-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .next-fruit-preview {
            width: 50px;
            height: 50px;
            margin: 0 auto;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Ê∏∏ÊàèÂÜÖÂÆπÂ±Ö‰∏≠ÂÆπÂô® */
        .game-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ÁôªÂΩïÊ≥®ÂÜåÂå∫Âüü -->
        <div class="auth-section" id="authSection">
            <!-- ÁôªÂΩïË°®Âçï -->
            <div id="loginSection">
                <h2>Áî®Êà∑ÁôªÂΩï</h2>
                <div id="loginMessage" class="message"></div>
                <form id="loginForm">
                    <div class="form-group">
                        <label for="username">Áî®Êà∑Âêç:</label>
                        <input type="text" id="username" name="username" required 
                               placeholder="ËØ∑ËæìÂÖ•Áî®Êà∑Âêç">
                    </div>
                    <div class="form-group">
                        <label for="password">ÂØÜÁ†Å:</label>
                        <input type="password" id="password" name="password" required 
                               placeholder="ËØ∑ËæìÂÖ•ÂØÜÁ†Å">
                    </div>
                    <button type="submit">ÁôªÂΩï</button>
                </form>
                
                <div class="switch-text">
                    ËøòÊ≤°ÊúâË¥¶Âè∑Ôºü <span class="switch-link" onclick="showRegister()">Á´ãÂç≥Ê≥®ÂÜå</span>
                </div>
            </div>

            <!-- Ê≥®ÂÜåË°®Âçï -->
            <div id="registerSection" class="hidden">
                <h2>Áî®Êà∑Ê≥®ÂÜå</h2>
                <div id="registerMessage" class="message"></div>
                <form id="registerForm">
                    <div class="form-group">
                        <label for="regUsername">Áî®Êà∑Âêç:</label>
                        <input type="text" id="regUsername" name="username" required 
                               placeholder="3-20‰∏™Â≠óÁ¨¶">
                    </div>
                    <div class="form-group">
                        <label for="regPassword">ÂØÜÁ†Å:</label>
                        <input type="password" id="regPassword" name="password" required 
                               placeholder="Ëá≥Â∞ë6‰∏™Â≠óÁ¨¶">
                    </div>
                    <div class="form-group">
                        <label for="confirmPassword">Á°ÆËÆ§ÂØÜÁ†Å:</label>
                        <input type="password" id="confirmPassword" name="confirmPassword" required 
                               placeholder="ÂÜçÊ¨°ËæìÂÖ•ÂØÜÁ†Å">
                    </div>
                    <button type="submit">Ê≥®ÂÜå</button>
                </form>
                
                <button type="button" class="secondary-btn" onclick="showLogin()">ËøîÂõûÁôªÂΩï</button>
            </div>
        </div>

        <!-- Ê∏∏ÊàèÂå∫Âüü -->
        <div class="game-section" id="gameSection">
            <div class="game-content">
                <div class="game-header">
                    <div class="header-left">
                        <button class="logout-btn" onclick="handleLogout()">ÈÄÄÂá∫ÁôªÂΩï</button>
                        <h3>Ê¨¢Ëøé, <span id="welcomeUser">Áî®Êà∑</span>!</h3>
                    </div>
                    <div class="score-container">
                        <div class="score-box">
                            <div class="score-label">ÂΩìÂâçÂàÜÊï∞</div>
                            <div class="score-value" id="currentScore">0</div>
                        </div>
                        <div class="score-box">
                            <div class="score-label">ÊúÄÈ´òÂàÜÊï∞</div>
                            <div class="score-value" id="highScore">0</div>
                        </div>
                    </div>
                </div>

                <div class="next-fruit">
                    <div class="next-fruit-label">‰∏ã‰∏Ä‰∏™Ê∞¥Êûú</div>
                    <div class="next-fruit-preview" id="nextFruitPreview"></div>
                </div>

                <div class="game-area" id="gameArea">
                    <canvas id="gameCanvas"></canvas>
                    
                    <div class="game-over" id="gameOver">
                        <h2>Ê∏∏ÊàèÁªìÊùü!</h2>
                        <p>ÂæóÂàÜ: <span id="finalScore">0</span></p>
                        <button onclick="restartGame()">ÂÜçÁé©‰∏ÄÊ¨°</button>
                    </div>
                </div>

                <!-- ÂõæÊ†áÊåâÈíÆ -->
                <div class="game-controls">
                    <button class="control-btn" onclick="restartGame()" title="ÈáçÊñ∞ÂºÄÂßã">üîÑ</button>
                    <button class="control-btn leaderboard-btn" onclick="showLeaderboard()" title="ÊéíË°åÊ¶ú">üèÜ</button>
                </div>

                <!-- ÊéíË°åÊ¶úÂºπÁ™ó -->
                <div class="leaderboard-modal" id="leaderboardModal">
                    <div class="leaderboard-content">
                        <button class="close-btn" onclick="hideLeaderboard()">√ó</button>
                        <h3>üèÜ ÊéíË°åÊ¶ú</h3>
                        <div class="leaderboard-list" id="leaderboardList">
                            <div class="leaderboard-item">
                                <span>Âä†ËΩΩ‰∏≠...</span>
                                <span>-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Ê∏∏ÊàèÈÖçÁΩÆ
        const config = {
            canvasWidth: 500,
            canvasHeight: 600,
            gravity: 0.5,
            friction: 0.9,
            restitution: 0.2,
            fruitTypes: [
                { name: 'Ëë°ËêÑ', radius: 20, color: '#8B008B', score: 1, emoji: 'üçá' },
                { name: 'Ê®±Ê°É', radius: 28, color: '#DC143C', score: 2, emoji: 'üçí' },
                { name: 'ËçâËéì', radius: 38, color: '#FF4500', score: 3, emoji: 'üçì' },
                { name: 'Ê©òÂ≠ê', radius: 46, color: '#FF8C00', score: 4, emoji: 'üçä' },
                { name: 'ËãπÊûú', radius: 56, color: '#FF0000', score: 5, emoji: 'üçé' },
                { name: 'Ê¢®', radius: 64, color: '#DAA520', score: 6, emoji: 'üçê' },
                { name: 'Ê°ÉÂ≠ê', radius: 74, color: '#FFD700', score: 7, emoji: 'üçë' },
                { name: 'Ëè†Ëêù', radius: 82, color: '#FFD700', score: 8, emoji: 'üçç' },
                { name: 'ÂìàÂØÜÁìú', radius: 90, color: '#98FB98', score: 9, emoji: 'üçà' },
                { name: 'Ë•øÁìú', radius: 98, color: '#228B22', score: 10, emoji: 'üçâ' }
            ]
        };

        // Ê∏∏ÊàèÁä∂ÊÄÅ
        let gameState = {
            score: 0,
            highScore: 0,
            fruits: [],
            currentFruit: null,
            nextFruitType: 0,
            isGameOver: false,
            isDropping: false,
            currentPosition: 250,
            sessionId: null,
            username: null,
            canvasScale: 1
        };

        // DOMÂÖÉÁ¥†
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const authSection = document.getElementById('authSection');
        const gameSection = document.getElementById('gameSection');
        const loginSection = document.getElementById('loginSection');
        const registerSection = document.getElementById('registerSection');
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        const loginMessage = document.getElementById('loginMessage');
        const registerMessage = document.getElementById('registerMessage');
        const currentScoreEl = document.getElementById('currentScore');
        const highScoreEl = document.getElementById('highScore');
        const welcomeUserEl = document.getElementById('welcomeUser');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const leaderboardList = document.getElementById('leaderboardList');
        const gameArea = document.getElementById('gameArea');
        const nextFruitPreviewEl = document.getElementById('nextFruitPreview');
        const leaderboardModal = document.getElementById('leaderboardModal');

        // APIÂü∫Á°ÄURL
        const apiBase = 'http://localhost:8080/api';

        // ËÆ°ÁÆóCanvasÁº©ÊîæÊØî‰æã
        function calculateCanvasScale() {
            const rect = gameArea.getBoundingClientRect();
            gameState.canvasScale = canvas.width / rect.width;
        }
        // ÁôªÂΩïÂ∫îÁî®Á±ª
        class LoginApp {
            constructor() {
                this.sessionId = localStorage.getItem('sessionId');
                this.initializeElements();
                this.checkAuthentication();
                this.attachEventListeners();
            }

            initializeElements() {
                // Â∑≤ÁªèÂú®ÂÖ®Â±ÄÂÆö‰πâ
            }

            attachEventListeners() {
                loginForm.addEventListener('submit', (e) => this.handleLogin(e));
                registerForm.addEventListener('submit', (e) => this.handleRegister(e));
            }

            async checkAuthentication() {
                if (!this.sessionId) {
                    this.showAuth();
                    return;
                }

                try {
                    const response = await this.apiCall('/checkAuth', {
                        sessionId: this.sessionId
                    });

                    if (response.authenticated === 'true') {
                        gameState.sessionId = this.sessionId;
                        gameState.username = response.username;
                        gameState.highScore = parseInt(response.highScore) || 0;
                        this.showGame();
                        loadLeaderboard();
                    } else {
                        this.showAuth();
                    }
                } catch (error) {
                    console.error('ËÆ§ËØÅÊ£ÄÊü•Â§±Ë¥•:', error);
                    this.showAuth();
                }
            }

            async handleLogin(event) {
                event.preventDefault();
                
                const formData = new FormData(loginForm);
                const username = formData.get('username');
                const password = formData.get('password');

                this.showMessage(loginMessage, '', 'hidden');

                try {
                    const response = await this.apiCall('/login', {
                        username: username,
                        password: password
                    });

                    if (response.success === 'true') {
                        this.sessionId = response.sessionId;
                        gameState.sessionId = response.sessionId;
                        gameState.username = response.username;
                        gameState.highScore = parseInt(response.highScore) || 0;
                        localStorage.setItem('sessionId', this.sessionId);
                        this.showGame();
                        loadLeaderboard();
                        
                        // Âä†ËΩΩÁî®Êà∑Ê∏∏ÊàèÁä∂ÊÄÅ
                        loadUserGameState(response);
                    } else {
                        this.showMessage(loginMessage, response.error || 'ÁôªÂΩïÂ§±Ë¥•', 'error');
                    }
                } catch (error) {
                    this.showMessage(loginMessage, 'ÁΩëÁªúÈîôËØØÔºåËØ∑Ê£ÄÊü•ÊúçÂä°Âô®ÊòØÂê¶ÂêØÂä®', 'error');
                }
            }

            async handleRegister(event) {
                event.preventDefault();
                
                const formData = new FormData(registerForm);
                const username = formData.get('username');
                const password = formData.get('password');
                const confirmPassword = document.getElementById('confirmPassword').value;

                this.showMessage(registerMessage, '', 'hidden');

                try {
                    const response = await this.apiCall('/register', {
                        username: username,
                        password: password,
                        confirmPassword: confirmPassword
                    });

                    if (response.success === 'true') {
                        this.showMessage(registerMessage, response.message || 'Ê≥®ÂÜåÊàêÂäü!', 'success');
                        registerForm.reset();
                        setTimeout(() => {
                            this.showLogin();
                        }, 2000);
                    } else {
                        this.showMessage(registerMessage, response.error || 'Ê≥®ÂÜåÂ§±Ë¥•', 'error');
                    }
                } catch (error) {
                    this.showMessage(registerMessage, 'ÁΩëÁªúÈîôËØØÔºåËØ∑Ê£ÄÊü•ÊúçÂä°Âô®ÊòØÂê¶ÂêØÂä®', 'error');
                }
            }

            async handleLogout() {
                try {
                    // ÈÄÄÂá∫Ââç‰øùÂ≠òÊ∏∏ÊàèÁä∂ÊÄÅ
                   await saveGameState();
                    
                    await this.apiCall('/logout', {
                        sessionId: gameState.sessionId,
                        currentScore: gameState.score,
                        nextFruitType: gameState.nextFruitType,
                        isGameOver: gameState.isGameOver,
                        fruits: gameState.fruits.map(f => 
                            `${f.type}#${f.x}#${f.y}#${f.vx}#${f.vy}#${f.radius}#${f.isDropped}`
                        ).join(';')
                    });
                } catch (error) {
                    console.error('ÈÄÄÂá∫ÁôªÂΩïÂ§±Ë¥•:', error);
                } finally {
                    this.sessionId = null;
                    gameState.sessionId = null;
                    gameState.username = null;
                    localStorage.removeItem('sessionId');
                    this.showAuth();
                }
            }

            async apiCall(endpoint, data) {
                const response = await fetch(`${apiBase}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                return await response.json();
            }

            showAuth() {
                authSection.style.display = 'block';
                gameSection.style.display = 'none';
                this.showLogin();
            }

            showGame() {
                authSection.style.display = 'none';
                gameSection.style.display = 'block';
                welcomeUserEl.textContent = gameState.username;
                highScoreEl.textContent = gameState.highScore;
            }

            showLogin() {
                loginSection.style.display = 'block';
                registerSection.style.display = 'none';
                loginForm.reset();
            }

            showRegister() {
                loginSection.style.display = 'none';
                registerSection.style.display = 'block';
                registerForm.reset();
                this.showMessage(registerMessage, '', 'hidden');
            }

            showMessage(element, message, type) {
                element.textContent = message;
                element.className = `message ${type}`;
                element.style.display = 'block';
                
                if (type === 'success') {
                    setTimeout(() => {
                        element.style.display = 'none';
                    }, 5000);
                }
            }
        }

        // Âä†ËΩΩÁî®Êà∑Ê∏∏ÊàèÁä∂ÊÄÅ
        function loadUserGameState(loginResponse) {
            gameState.score = parseInt(loginResponse.currentScore) || 0;
            gameState.nextFruitType = parseInt(loginResponse.nextFruitType) || 0;
            gameState.isGameOver = loginResponse.isGameOver === 'true';
            
            // Âä†ËΩΩÊ∞¥ÊûúÁä∂ÊÄÅ
            gameState.fruits = [];
            if (loginResponse.fruits && loginResponse.fruits !== '') {
                const fruitArray = loginResponse.fruits.split(';');
                for (let fruitStr of fruitArray) {
                    const parts = fruitStr.split('#');
                    if (parts.length === 7) {
                        gameState.fruits.push({
                            type: parseInt(parts[0]),
                            x: parseFloat(parts[1]),
                            y: parseFloat(parts[2]),
                            vx: parseFloat(parts[3]),
                            vy: parseFloat(parts[4]),
                            radius: parseFloat(parts[5]),
                            isDropped: parts[6] === 'true'
                        });
                    }
                }
            }
            
            updateScore();
            updateNextFruitPreview();
            
            if (!gameState.isGameOver) {
                requestAnimationFrame(gameLoop);
            } else {
                gameOverEl.style.display = 'flex';
                finalScoreEl.textContent = gameState.score;
            }
        }
        // ÂàùÂßãÂåñÊ∏∏Êàè
        function initGame() {
            canvas.width = config.canvasWidth;
            canvas.height = config.canvasHeight;
            
            // ËÆ°ÁÆóÁº©ÊîæÊØî‰æã
            calculateCanvasScale();
            
            gameState.score = 0;
            gameState.fruits = [];
            gameState.currentFruit = null;
            gameState.nextFruitType = Math.floor(Math.random() * 3);
            gameState.isGameOver = false;
            gameState.isDropping = false;
            gameState.currentPosition = canvas.width / 2;
            
            updateScore();
            updateNextFruitPreview();
            createNewFruit();
            gameOverEl.style.display = 'none';
            
            requestAnimationFrame(gameLoop);
        }

        function createNewFruit() {
            const fruitType = config.fruitTypes[gameState.nextFruitType];
            gameState.currentFruit = {
                type: gameState.nextFruitType,
                x: gameState.currentPosition,
                y: 50,
                radius: fruitType.radius,
                color: fruitType.color,
                vx: 0,
                vy: 0,
                isDropped: false
            };
            
            gameState.nextFruitType = Math.floor(Math.random() * 3);
            updateNextFruitPreview();
        }

        function updateNextFruitPreview() {
            const nextFruitType = config.fruitTypes[gameState.nextFruitType];
            nextFruitPreviewEl.style.background = nextFruitType.color;
            nextFruitPreviewEl.innerHTML = nextFruitType.emoji;
        }

        function dropFruit() {
            if (gameState.isDropping || gameState.isGameOver || !gameState.currentFruit) return;
            
            gameState.isDropping = true;
            gameState.currentFruit.isDropped = true;
            gameState.fruits.push(gameState.currentFruit);
            
            // ‰øùÂ≠òÊ∏∏ÊàèÁä∂ÊÄÅ
            saveGameState();
            
            setTimeout(() => {
                createNewFruit();
                gameState.isDropping = false;
                checkGameOver();
            }, 500);
        }

        function updateFruitPosition(clientX) {
            if (gameState.isDropping || gameState.isGameOver) return;
            
            const rect = gameArea.getBoundingClientRect();
            const canvasX = (clientX - rect.left) * gameState.canvasScale;
            
            const fruitRadius = gameState.currentFruit ? gameState.currentFruit.radius : 25;
            const minX = fruitRadius;
            const maxX = canvas.width - fruitRadius;
            
            gameState.currentPosition = Math.max(minX, Math.min(maxX, canvasX));
            
            if (gameState.currentFruit) {
                gameState.currentFruit.x = gameState.currentPosition;
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            updateFruits();
            drawFruits();
            
            if (gameState.currentFruit && !gameState.currentFruit.isDropped) {
                drawFruit(gameState.currentFruit);
            }
            
            if (!gameState.isGameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a2a6c');
            gradient.addColorStop(1, '#b21f1f');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(139, 69, 19, 0.7)';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
        }

        function updateFruits() {
            for (let i = 0; i < gameState.fruits.length; i++) {
                const fruit = gameState.fruits[i];
                
                // Â∫îÁî®Áâ©ÁêÜÊïàÊûú
                fruit.vy += config.gravity;
                fruit.x += fruit.vx;
                fruit.y += fruit.vy;
                
                // ËæπÁïåÁ¢∞Êíû
                if (fruit.x - fruit.radius < 0) {
                    fruit.x = fruit.radius;
                    fruit.vx *= -config.restitution;
                } else if (fruit.x + fruit.radius > canvas.width) {
                    fruit.x = canvas.width - fruit.radius;
                    fruit.vx *= -config.restitution;
                }
                
                // Âú∞Èù¢Á¢∞Êíû
                if (fruit.y + fruit.radius > canvas.height - 20) {
                    fruit.y = canvas.height - 20 - fruit.radius;
                    fruit.vy *= -config.restitution;
                    fruit.vx *= config.friction;
                    
                    // ÂÅúÊ≠¢ÂæÆÂ∞èËøêÂä®
                    if (Math.abs(fruit.vy) < 0.5) fruit.vy = 0;
                    if (Math.abs(fruit.vx) < 0.1) fruit.vx = 0;
                }
                
                // Ê∞¥ÊûúÈó¥Á¢∞ÊíûÊ£ÄÊµã
                for (let j = i + 1; j < gameState.fruits.length; j++) {
                    checkCollision(fruit, gameState.fruits[j]);
                }
            }
        }

        function drawFruits() {
            gameState.fruits.forEach(fruit => drawFruit(fruit));
        }

        function drawFruit(fruit) {
            const fruitType = config.fruitTypes[fruit.type];
            
            // ÁªòÂà∂Ê∞¥Êûú‰∏ª‰Ωì
            ctx.beginPath();
            ctx.arc(fruit.x, fruit.y, fruit.radius, 0, Math.PI * 2);
            ctx.fillStyle = fruitType.color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ÁªòÂà∂È´òÂÖâ
            ctx.beginPath();
            ctx.arc(fruit.x - fruit.radius * 0.2, fruit.y - fruit.radius * 0.2, fruit.radius * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fill();
            
            // ÁªòÂà∂Ë°®ÊÉÖ
            ctx.font = `${fruit.radius * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText(fruitType.emoji, fruit.x, fruit.y);
        }

        function checkCollision(fruit1, fruit2) {
            const dx = fruit1.x - fruit2.x;
            const dy = fruit1.y - fruit2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < fruit1.radius + fruit2.radius) {
                // Á¢∞ÊíûÂìçÂ∫î
                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);
                
                // ÊóãËΩ¨ÈÄüÂ∫¶ÂêëÈáè
                const vx1 = fruit1.vx * cos + fruit1.vy * sin;
                const vy1 = fruit1.vy * cos - fruit1.vx * sin;
                const vx2 = fruit2.vx * cos + fruit2.vy * sin;
                const vy2 = fruit2.vy * cos - fruit2.vx * sin;
                
                // Á¢∞ÊíûÂêéÈÄüÂ∫¶
                const finalVx1 = ((fruit1.radius - fruit2.radius) * vx1 + 2 * fruit2.radius * vx2) / (fruit1.radius + fruit2.radius);
                const finalVx2 = ((fruit2.radius - fruit1.radius) * vx2 + 2 * fruit1.radius * vx1) / (fruit1.radius + fruit2.radius);
                
                // Êõ¥Êñ∞ÈÄüÂ∫¶
                fruit1.vx = finalVx1 * cos - vy1 * sin;
                fruit1.vy = vy1 * cos + finalVx1 * sin;
                fruit2.vx = finalVx2 * cos - vy2 * sin;
                fruit2.vy = vy2 * cos + finalVx2 * sin;
                
                // Èò≤Ê≠¢ÈáçÂè†
                const overlap = fruit1.radius + fruit2.radius - distance;
                fruit1.x += overlap * cos * 0.5;
                fruit1.y += overlap * sin * 0.5;
                fruit2.x -= overlap * cos * 0.5;
                fruit2.y -= overlap * sin * 0.5;
                
                // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÂêàÊàê
                if (fruit1.type === fruit2.type && fruit1.type < config.fruitTypes.length - 1) {
                    const index1 = gameState.fruits.indexOf(fruit1);
                    const index2 = gameState.fruits.indexOf(fruit2);
                    
                    if (index1 > -1 && index2 > -1 && index1 !== index2) {
                        // ÁßªÈô§Ëøô‰∏§‰∏™Ê∞¥Êûú
                        gameState.fruits.splice(Math.max(index1, index2), 1);
                        gameState.fruits.splice(Math.min(index1, index2), 1);
                        
                        // ÂàõÂª∫Êñ∞Ê∞¥Êûú
                        const newFruitType = fruit1.type + 1;
                        const newFruit = {
                            type: newFruitType,
                            x: (fruit1.x + fruit2.x) / 2,
                            y: (fruit1.y + fruit2.y) / 2,
                            radius: config.fruitTypes[newFruitType].radius,
                            color: config.fruitTypes[newFruitType].color,
                            vx: (fruit1.vx + fruit2.vx) * 0.3,
                            vy: (fruit1.vy + fruit2.vy) * 0.3 - 2,
                            isDropped: true
                        };
                        
                        gameState.fruits.push(newFruit);
                        gameState.score += config.fruitTypes[newFruitType].score * 10;
                        updateScore();
                        
                        // ‰øùÂ≠òÊ∏∏ÊàèÁä∂ÊÄÅ
                        saveGameState();
                    }
                }
            }
        }

        function updateScore() {
            currentScoreEl.textContent = gameState.score;
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                highScoreEl.textContent = gameState.highScore;
            }
        }

        function checkGameOver() {
            for (let fruit of gameState.fruits) {
                if (fruit.y - fruit.radius < 100&&Math.abs(fruit.vx) < 0.5 && Math.abs(fruit.vy) < 0.5) {
                    endGame();
                    return;
                }
            }
        }

        function endGame() {
            gameState.isGameOver = true;
            finalScoreEl.textContent = gameState.score;
            gameOverEl.style.display = 'flex';
            
            // ‰øùÂ≠òÊúÄÁªàÂàÜÊï∞
            saveScore(gameState.score);
            // ‰øùÂ≠òÊ∏∏ÊàèÁªìÊùüÁä∂ÊÄÅ
            saveGameState();
            
            // Â¶ÇÊûúÊéíË°åÊ¶úÂºπÁ™óÊòØÊâìÂºÄÁöÑÔºåÂà∑Êñ∞ÊéíË°åÊ¶úÊï∞ÊçÆ
            if (leaderboardModal.style.display === 'flex') {
                loadLeaderboard();
            }
        }

        function restartGame() {
            initGame();
            // ‰øùÂ≠òÈáçÊñ∞ÂºÄÂßãÁöÑÁä∂ÊÄÅ
            saveGameState();
        }

        // ÊòæÁ§∫ÊéíË°åÊ¶úÂºπÁ™ó
        function showLeaderboard() {
            loadLeaderboard();
            leaderboardModal.style.display = 'flex';
        }

        // ÈöêËóèÊéíË°åÊ¶úÂºπÁ™ó
        function hideLeaderboard() {
            leaderboardModal.style.display = 'none';
        }

        // API ÂäüËÉΩ
        async function saveGameState() {
            if (!gameState.sessionId) return;
            
            try {
                const fruitsData = gameState.fruits.map(f => 
                    `${f.type}#${f.x}#${f.y}#${f.vx}#${f.vy}#${f.radius}#${f.isDropped}`
                ).join(';');

          console.log('üîç ÂèëÈÄÅÂà∞ÂêéÁ´ØÁöÑÊï∞ÊçÆ:', {
            sessionId: gameState.sessionId,
            currentScore: gameState.score,
            nextFruitType: gameState.nextFruitType,
            isGameOver: gameState.isGameOver,
            fruits: fruitsData,
            fruitsCount: gameState.fruits.length
        });

                await fetch(`${apiBase}/updateGame`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: gameState.sessionId,
                        currentScore: gameState.score,
                        nextFruitType: gameState.nextFruitType,
                        isGameOver: gameState.isGameOver,
                        fruits: fruitsData
                    })
                });
            } catch (error) {
                console.error('‰øùÂ≠òÊ∏∏ÊàèÁä∂ÊÄÅÂ§±Ë¥•:', error);
            }
        }

        async function saveScore(score) {
            if (!gameState.sessionId) return;
            
            try {
                const response = await fetch(`${apiBase}/saveScore`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: gameState.sessionId,
                        score: score
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    gameState.highScore = parseInt(result.highScore);
                    highScoreEl.textContent = gameState.highScore;
                    if (result.isNewHighScore === 'true') {
                        loadLeaderboard();
                    }
                }
            } catch (error) {
                console.error('‰øùÂ≠òÂàÜÊï∞Â§±Ë¥•:', error);
            }
        }

        async function loadLeaderboard() {
            try {
                const response = await fetch(`${apiBase}/leaderboard`);
                const result = await response.json();
                
                if (result.success) {
                    leaderboardList.innerHTML = '';
                    result.leaderboard.forEach((entry, index) => {
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        item.innerHTML = `
                            <span>${index + 1}. ${entry.username}</span>
                            <span>${entry.score}</span>
                        `;
                        leaderboardList.appendChild(item);
                    });
                    
                    if (result.leaderboard.length === 0) {
                        leaderboardList.innerHTML = '<div class="leaderboard-item"><span>ÊöÇÊó†Êï∞ÊçÆ</span><span>-</span></div>';
                    }
                }
            } catch (error) {
                console.error('Âä†ËΩΩÊéíË°åÊ¶úÂ§±Ë¥•:', error);
                leaderboardList.innerHTML = '<div class="leaderboard-item"><span>Âä†ËΩΩÂ§±Ë¥•</span><span>-</span></div>';
            }
        }

        // ‰∫ã‰ª∂ÁõëÂê¨
        gameArea.addEventListener('mousemove', (e) => {
            updateFruitPosition(e.clientX);
        });

        gameArea.addEventListener('click', () => {
            if (!gameState.isDropping && !gameState.isGameOver) {
                dropFruit();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                dropFruit();
                e.preventDefault();
            }
        });

        // ÁÇπÂáªÂºπÁ™óÂ§ñÈÉ®ÂÖ≥Èó≠
        leaderboardModal.addEventListener('click', (e) => {
            if (e.target === leaderboardModal) {
                hideLeaderboard();
            }
        });

        // ÊåâESCÈîÆÂÖ≥Èó≠ÂºπÁ™ó
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape' && leaderboardModal.style.display === 'flex') {
                hideLeaderboard();
            }
        });

        // Á™óÂè£Â§ßÂ∞èÂèòÂåñÊó∂ÈáçÊñ∞ËÆ°ÁÆóÁº©ÊîæÊØî‰æã
        window.addEventListener('resize', calculateCanvasScale);

        // ÂÖ®Â±ÄÂáΩÊï∞
        function showRegister() {
            window.loginApp.showRegister();
        }

        function showLogin() {
            window.loginApp.showLogin();
        }

        function handleLogout() {
            window.loginApp.handleLogout();
        }
      // ÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', () => {
            window.loginApp = new LoginApp();
        });
    </script>
</body>
</html>
